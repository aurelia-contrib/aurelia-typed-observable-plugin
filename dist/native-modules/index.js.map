{"version":3,"file":"index.js","sources":["../../src/coerce-functions.ts","../../src/patches.ts","../../src/bindable.ts","../../src/observable.ts"],"sourcesContent":["import { ICoerceFunction } from './interfaces';\r\nimport * as LogManager from 'aurelia-logging';\r\n\r\nexport const coerceFunctions: Record<string, (val: any) => any> = {\r\n  none(a: any) {\r\n    return a;\r\n  },\r\n  number(a: any) {\r\n    return Number(a);\r\n  },\r\n  string(a: any) {\r\n    return '' + a;\r\n  },\r\n  boolean(a: any) {\r\n    return !!a;\r\n  },\r\n  booleanAttr(val: any) {\r\n    return val || val === '' ? true : false;\r\n  },\r\n  date(val: any) {\r\n    // Invalid date instances are quite problematic\r\n    // so we need to deal with it properly by default\r\n    if (val === null || val === undefined) {\r\n      return null;\r\n    }\r\n    const d = new Date(val);\r\n    return isNaN(d.getTime()) ? null : d;\r\n  }\r\n};\r\n\r\n\r\nexport const coerceFunctionMap: Map<Function, string> = new Map([\r\n  [Boolean, 'boolean'],\r\n  [String, 'string'],\r\n  [Date, 'date'],\r\n  [Number, 'number'],\r\n] as any);\r\n\r\nexport interface ICoerce extends Function {\r\n  coerce?: ICoerceFunction;\r\n}\r\n\r\n/**\r\n * Map a class to a string for typescript property coerce\r\n * @param type the property class to register\r\n * @param strType the string that represents class in the lookup\r\n * @param coerceFunction coerce function to register with param strType\r\n */\r\nexport function mapCoerceFunction(type: ICoerce, strType: string, coerceFunction?: ICoerceFunction) {\r\n  coerceFunction = coerceFunction || type.coerce;\r\n  if (typeof strType !== 'string' || typeof coerceFunction !== 'function') {\r\n    LogManager\r\n      .getLogger('map-coerce-function')\r\n      .warn(`Bad attempt at mapping coerce function for type: ${type.name} to: ${strType}`);\r\n    return;\r\n  }\r\n  coerceFunctions[strType] = coerceFunction;\r\n  coerceFunctionMap.set(type, strType);\r\n}\r\n","// tslint:disable: interface-name no-invalid-this no-non-null-assertion\r\nimport * as LogManager from 'aurelia-logging';\r\nimport { TaskQueue } from 'aurelia-task-queue';\r\nimport { BehaviorPropertyObserver, BindableProperty, HtmlBehaviorResource } from 'aurelia-templating';\r\nimport { coerceFunctions } from './coerce-functions';\r\nimport { ICoerceFunction } from './interfaces';\r\n\r\n/** @internal */\r\ndeclare module 'aurelia-templating' {\r\n  interface BehaviorPropertyObserver {\r\n    coerce?: ICoerceFunction;\r\n    // currentValue: any;\r\n    // oldValue: any;\r\n    // selfSubscriber: Function | null;\r\n    setCoerce(coerce: string | Function | undefined): void;\r\n  }\r\n\r\n  interface BindableProperty {\r\n    name: any;\r\n    coerce: string | ICoerceFunction | undefined;\r\n  }\r\n}\r\n\r\ninterface ExtendedBehaviorPropertyObserver extends BehaviorPropertyObserver {\r\n  // coerce?: ICoerceFunction;\r\n  currentValue: any;\r\n  oldValue: any;\r\n  selfSubscriber: Function | null;\r\n  notqueued: boolean;\r\n  publishing: boolean;\r\n  taskQueue: TaskQueue;\r\n  // setCoerce(coerce: string | Function | undefined): void;\r\n}\r\n\r\ninterface BindablePropertyForeignExtension {\r\n  changeHandler: string;\r\n  defaultValue: any;\r\n  owner: HtmlBehaviorResource & { taskQueue: TaskQueue };\r\n}\r\n\r\ninterface ExtendedBindableProperty extends BindableProperty {\r\n  changeHandler: string;\r\n  defaultValue: any;\r\n  owner: HtmlBehaviorResource & { taskQueue: TaskQueue };\r\n}\r\n\r\nBehaviorPropertyObserver.prototype.setCoerce = function(coerce: string | ICoerceFunction): void {\r\n  this.coerce = typeof coerce === 'function' ? coerce : coerceFunctions[coerce];\r\n  if (this.coerce === undefined) {\r\n    LogManager\r\n      .getLogger('behavior-property-observer')\r\n      .warn(`Invalid coerce instruction. Should be either one of ${Object.keys(coerceFunctions)} or a function.`);\r\n  }\r\n};\r\n\r\n/**\r\n * Slightly override the builtin implementation that will handle coercion\r\n */\r\nBehaviorPropertyObserver.prototype.setValue = function(\r\n  this: BehaviorPropertyObserver & ExtendedBehaviorPropertyObserver,\r\n  newValue: any\r\n): void {\r\n  const oldValue = this.currentValue;\r\n  const coercedValue = this.coerce === undefined ? newValue : this.coerce(newValue);\r\n\r\n  if (oldValue !== coercedValue) {\r\n    this.oldValue = oldValue;\r\n    this.currentValue = coercedValue;\r\n\r\n    if (this.publishing && this.notqueued) {\r\n      if (this.taskQueue.flushing) {\r\n        this.call();\r\n      } else {\r\n        this.notqueued = false;\r\n        this.taskQueue.queueMicroTask(this);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nBindableProperty.prototype.createObserver = function(\r\n  this: ExtendedBindableProperty,\r\n  viewModel: any\r\n): BehaviorPropertyObserver {\r\n  let selfSubscriber: Function | null = null;\r\n  const defaultValue = this.defaultValue;\r\n  const changeHandlerName = this.changeHandler;\r\n  const name = this.name;\r\n  let initialValue;\r\n\r\n  if ((this as any).hasOptions) {\r\n    return undefined;\r\n  }\r\n\r\n  if (changeHandlerName in viewModel) {\r\n    if ('propertyChanged' in viewModel) {\r\n      selfSubscriber = (newValue: any, oldValue: any) => {\r\n        viewModel[changeHandlerName](newValue, oldValue);\r\n        viewModel.propertyChanged(name, newValue, oldValue);\r\n      };\r\n    } else {\r\n      selfSubscriber = (newValue: any, oldValue: any) => viewModel[changeHandlerName](newValue, oldValue);\r\n    }\r\n  } else if ('propertyChanged' in viewModel) {\r\n    selfSubscriber = (newValue: any, oldValue: any) => viewModel.propertyChanged(name, newValue, oldValue);\r\n  } else if (changeHandlerName !== null) {\r\n    throw new Error(`Change handler ${changeHandlerName} was specified but not declared on the class.`);\r\n  }\r\n\r\n  if (defaultValue !== undefined) {\r\n    initialValue = typeof defaultValue === 'function' ? defaultValue.call(viewModel) : defaultValue;\r\n  }\r\n\r\n  const observer: ExtendedBehaviorPropertyObserver = new BehaviorPropertyObserver(\r\n    this.owner.taskQueue,\r\n    viewModel,\r\n    this.name,\r\n    selfSubscriber,\r\n    initialValue\r\n  ) as any;\r\n  if (this.coerce !== undefined) {\r\n    observer.setCoerce(this.coerce);\r\n    observer.currentValue = observer.oldValue = observer.coerce === undefined ? observer.currentValue : observer.coerce(initialValue);\r\n  }\r\n\r\n  return observer;\r\n};\r\n\r\n(BindableProperty as any).prototype._createDynamicProperty = function(\r\n  this: BindableProperty & BindablePropertyForeignExtension,\r\n  viewModel: any,\r\n  observerLookup: Record<string, ExtendedBehaviorPropertyObserver>,\r\n  behaviorHandlesBind: boolean,\r\n  name: string,\r\n  attribute: string | { createBinding(viewModel: any): any },\r\n  boundProperties: any[]\r\n): void {\r\n  const changeHandlerName = `${name}Changed`;\r\n  let selfSubscriber: Function | null = null;\r\n  let observer: ExtendedBehaviorPropertyObserver;\r\n  let info;\r\n\r\n  if (changeHandlerName in viewModel) {\r\n    if ('propertyChanged' in viewModel) {\r\n      selfSubscriber = (newValue: any, oldValue: any) => {\r\n        viewModel[changeHandlerName](newValue, oldValue);\r\n        viewModel.propertyChanged(name, newValue, oldValue);\r\n      };\r\n    } else {\r\n      selfSubscriber = (newValue: any, oldValue: any) => viewModel[changeHandlerName](newValue, oldValue);\r\n    }\r\n  } else if ('propertyChanged' in viewModel) {\r\n    selfSubscriber = (newValue: any, oldValue: any) => viewModel.propertyChanged(name, newValue, oldValue);\r\n  }\r\n\r\n  observer = observerLookup[name] = new BehaviorPropertyObserver(\r\n    this.owner.taskQueue,\r\n    viewModel,\r\n    name,\r\n    selfSubscriber,\r\n    undefined\r\n  ) as ExtendedBehaviorPropertyObserver;\r\n\r\n  observer.setCoerce(this.coerce);\r\n  observer.currentValue = observer.oldValue = observer.coerce === undefined ? observer.currentValue : observer.coerce(undefined);\r\n\r\n  Object.defineProperty(viewModel, name, {\r\n    configurable: true,\r\n    enumerable: true,\r\n    get: observer.getValue.bind(observer),\r\n    set: observer.setValue.bind(observer)\r\n  });\r\n\r\n  if (behaviorHandlesBind) {\r\n    observer.selfSubscriber = null;\r\n  }\r\n\r\n  if (typeof attribute === 'string') {\r\n    viewModel[name] = attribute;\r\n    observer.call();\r\n  } else if (attribute) {\r\n    info = { observer: observer, binding: attribute.createBinding(viewModel) };\r\n    boundProperties.push(info);\r\n  }\r\n\r\n  observer.publishing = true;\r\n  observer.selfSubscriber = selfSubscriber;\r\n};\r\n","// tslint:disable: no-reserved-keywords no-function-expressions no-parameter-reassignment no-import-side-effect callable-types\r\nimport { bindingMode } from 'aurelia-binding';\r\nimport * as LogManager from 'aurelia-logging';\r\nimport { metadata } from 'aurelia-metadata';\r\nimport { BindableProperty, HtmlBehaviorResource } from 'aurelia-templating';\r\nimport { coerceFunctionMap, coerceFunctions } from './coerce-functions';\r\nimport { IPropertyDecoratorConfig, IPropertyDecoratorFunction } from './interfaces';\r\nimport './patches';\r\n\r\nlet _usePropertyType = false;\r\n\r\nexport interface IBindablePropertyConfig<T = any> extends IPropertyDecoratorConfig<T> {\r\n  attribute?: string;\r\n  defaultBindingMode?: bindingMode;\r\n  reflectToAttribute?: boolean | { (el: Element, name: string, newVal: any, oldVal: any): any };\r\n}\r\n\r\nexport type IBindableDecoratorFunction<T = any> = IPropertyDecoratorFunction<T>\r\n\r\nexport interface IBindableDecorator<T = any> extends IBindableDecoratorFunction<T> {\r\n  string: IBindableDecoratorFunction<string>;\r\n  number: IBindableDecoratorFunction<number>;\r\n  boolean: IBindableDecoratorFunction<boolean>;\r\n  date: IBindableDecoratorFunction<Date>;\r\n  booleanAttr: IBindableDecoratorFunction<boolean>;\r\n  [type: string]: IBindableDecoratorFunction;\r\n}\r\n\r\n/**\r\n * Decorator: Specifies that a property is bindable through HTML.\r\n * @param nameOrTargetOrConfig The name of the property, or a configuration object.\r\n * This has Object in its type to avoid breaking change.\r\n * Idealy it should be `string | BindablePropertyConfig`\r\n */\r\n// tslint:disable-next-line:no-shadowed-variable\r\nexport const bindable: IBindableDecorator = function bindable(\r\n  nameOrTargetOrConfig?: string | object | IBindablePropertyConfig,\r\n  key?: string,\r\n  descriptor?: PropertyDescriptor\r\n): any {\r\n  const deco = function(target: Function, key2?: string, descriptor2?: PropertyDescriptor): any {\r\n    /**\r\n     * key2 = truthy => decorated on a class field\r\n     * key2 = falsy => decorated on a class\r\n     */\r\n    const actualTarget = key2 ? target.constructor : target;\r\n    const r = metadata.getOrCreateOwn(metadata.resource, HtmlBehaviorResource, actualTarget) as HtmlBehaviorResource;\r\n    let prop: BindableProperty;\r\n    let propType: Function;\r\n\r\n    if (key2) { //is it on a property or a class?\r\n      nameOrTargetOrConfig = nameOrTargetOrConfig || {};\r\n      (nameOrTargetOrConfig as IBindablePropertyConfig).name = key2;\r\n      /**\r\n       * Support for Typescript decorator, with metadata on property type.\r\n       * Will check for typing only when user didn't explicitly set coerce + turn on the options\r\n       *\r\n       * If key 2 is truthy, it's a decorator on class field, which means target is prototype\r\n       */\r\n      if ((nameOrTargetOrConfig as IBindablePropertyConfig).coerce === undefined && _usePropertyType) {\r\n        propType = metadata.getOwn(metadata.propertyType, target, key2) as any;\r\n        if (propType) {\r\n          const coerceType = coerceFunctionMap.get(propType);\r\n          if (coerceType === undefined) {\r\n            LogManager\r\n              .getLogger('@bindable decorator')\r\n              .warn(`Invalid coerce instruction. Should be either one of ${Object.keys(coerceFunctions)} or a function.`);\r\n          }\r\n          (nameOrTargetOrConfig as IBindablePropertyConfig).coerce = coerceType || 'none';\r\n        }\r\n      }\r\n    }\r\n\r\n    prop = new BindableProperty((nameOrTargetOrConfig as IBindablePropertyConfig));\r\n\r\n    return prop.registerWith(actualTarget, r, descriptor2);\r\n  };\r\n\r\n  if (!nameOrTargetOrConfig) {\r\n    /**\r\n     * placed on property initializer with parens, without any params\r\n     * @example:\r\n     * class ViewModel {\r\n     *   @bindable() property\r\n     * }\r\n     * @bindable() class ViewModel {}\r\n     */\r\n    return deco;\r\n  }\r\n\r\n  if (key) {\r\n    /**\r\n     * placed on a property initializer without parens\r\n     * @example\r\n     * class ViewModel {\r\n     *   @bindable property\r\n     * }\r\n     *\r\n     */\r\n    const target = nameOrTargetOrConfig;\r\n    nameOrTargetOrConfig = undefined;\r\n\r\n    return deco(target as Function, key, descriptor);\r\n  }\r\n\r\n  /**\r\n   * placed on a class with parens and config\r\n   * @example\r\n   * @bindable({ ... })\r\n   * class MyViewModel {}\r\n   */\r\n  return deco;\r\n} as IBindableDecorator;\r\n\r\n['string', 'number', 'boolean', 'booleanAttr', 'date'].forEach(createTypedBindable);\r\n\r\n/**\r\n * Used to allow user to automatically pickup property type\r\n * Can be used with typescript emit metadata in compiler settings, or with `Reflect.metadata('design:type', PropertyTypeClass)` decorator\r\n */\r\nexport function usePropertyType(shouldUsePropertyType: boolean): void {\r\n  _usePropertyType = shouldUsePropertyType;\r\n}\r\n\r\n/**\r\n * Create a new fluent syntax bindable decorator  ex: builtin: `@bindable.string`, custom: `@bindable.customType`\r\n * Need to use together with setting the type in `coerceFunctions`:\r\n *\r\n * ```js\r\n * import {\r\n *  createTypedBindable,\r\n *  coerceFunctions\r\n * } from 'aurelia-framework'\r\n *\r\n * // create the typed bindable\r\n * createTypedBindable('point'); // => enable `@bindable.point`\r\n * // Set the instruction\r\n * coerceFunctions.point = function(value: string) {\r\n *   // convert to point from value\r\n * }\r\n * ```\r\n *\r\n * @param type The type to added to bindable for fluent syntax.\r\n */\r\nexport function createTypedBindable(type: string): any {\r\n  /**\r\n   * There no attempts to protect user from mis-using the decorators.\r\n   * ex. @observable({}, accidentParam) class SomeClass {}\r\n   * If we have some flag to use in if block, which can be remove at build time, it would be great.\r\n   */\r\n  return (bindable as any)[type] = function(\r\n    nameOrTargetOrConfig?: string | object | IBindablePropertyConfig,\r\n    key?: string,\r\n    descriptor?: PropertyDescriptor\r\n  ): any {\r\n    if (nameOrTargetOrConfig === undefined) {\r\n      /**\r\n       * MyClass {\r\n       *   @bindable.number() num\r\n       * }\r\n       */\r\n      return bindable({ coerce: type });\r\n    }\r\n    if (key === undefined) {\r\n      /**\r\n       * @bindable.number('num')\r\n       * class MyClass {}\r\n       *\r\n       * @bindable.number({...})\r\n       * class MyClass\r\n       *\r\n       * class MyClass {\r\n       *   @bindable.number({...})\r\n       *   num\r\n       * }\r\n       */\r\n      nameOrTargetOrConfig = typeof nameOrTargetOrConfig === 'string' ? { name: nameOrTargetOrConfig } : nameOrTargetOrConfig;\r\n      (nameOrTargetOrConfig as IBindablePropertyConfig).coerce = type;\r\n\r\n      return bindable(nameOrTargetOrConfig);\r\n    }\r\n\r\n    /**\r\n     * class MyClass {\r\n     *   @bindable.number num\r\n     * }\r\n     */\r\n    return bindable({ coerce: type })(nameOrTargetOrConfig, key, descriptor);\r\n  };\r\n}\r\n","import { ICoerceFunction, IPropertyDecoratorConfig, IPropertyDecoratorFunction } from './interfaces';\r\nimport { coerceFunctions, coerceFunctionMap } from './coerce-functions';\r\nimport { metadata } from 'aurelia-metadata';\r\nimport * as LogManager from 'aurelia-logging';\r\n\r\nconst observableLogger = LogManager.getLogger('aurelia-observable-decorator');\r\n\r\n/**\r\n * Internal flag to turn on / off auto pickup property type from metadata\r\n */\r\nlet _usePropertyType = false;\r\n\r\n// export interface ObservablePropertyConfig<T = any> {\r\n//   name?: string;\r\n//   changeHandler?: string;\r\n//   defaultValue?: T;\r\n//   coerce?: string | ICoerceFunction<T>;\r\n// }\r\n\r\n// export type IObservableDecoratorFunction<T = any> = (nameOrTargetOrConfig: string | Function | ObservablePropertyConfig<T>, key?: string, descriptor?: PropertyDescriptor) => any;\r\n\r\nexport type IObservableDecoratorFunction<T = any> = IPropertyDecoratorFunction<T>\r\n\r\nexport interface IObservableDecorator extends IObservableDecoratorFunction {\r\n  // usePropertyType(shouldUsePropType: boolean): void;\r\n  string: IObservableDecoratorFunction<string>;\r\n  number: IObservableDecoratorFunction<number>;\r\n  boolean: IObservableDecoratorFunction<boolean>;\r\n  date: IObservableDecoratorFunction<Date>;\r\n  [type: string]: IObservableDecoratorFunction<any>;\r\n}\r\n\r\nexport const observable: IObservableDecorator = function observable(nameOrTargetOrConfig?: string | object | IPropertyDecoratorConfig, key?: string, descriptor?: PropertyDescriptor) {\r\n  /**\r\n   * @param target The class decorated\r\n   * @param key The target class field of the decorator\r\n   * @param descriptor class field descriptor\r\n   * @param config user's config\r\n   */\r\n  function deco(target: Function, key?: string, descriptor?: PropertyDescriptor & { initializer?(): any }, config?: string | IPropertyDecoratorConfig): any {\r\n    // Used to check if we should pickup the type from metadata\r\n    let coerce: string | ICoerceFunction | undefined = config === undefined || typeof config === 'string' ? undefined : config.coerce;\r\n    let propType: Function | undefined;\r\n    let coerceFunction: ICoerceFunction | undefined;\r\n\r\n    if (coerce) {\r\n      switch (typeof coerce) {\r\n        case 'string':\r\n          coerceFunction = coerceFunctions[coerce as string]; break;\r\n        case 'function':\r\n          coerceFunction = coerce as ICoerceFunction; break;\r\n        default: break;\r\n      }\r\n      if (coerceFunction === undefined) {\r\n        observableLogger.warn(`Invalid coerce instruction. Should be either one of ${Object.keys(coerceFunctions)} or a function.`);\r\n      }\r\n    } else if (_usePropertyType) {\r\n      propType = metadata.getOwn(metadata.propertyType, target, key) as any;\r\n      if (propType) {\r\n        coerceFunction = coerceFunctions[coerceFunctionMap.get(propType)];\r\n        if (coerceFunction === undefined) {\r\n          observableLogger.warn(`Unable to find coerce function for type ${propType.name}.`);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * class decorator?\r\n     * @example\r\n     * @observable('firstName') MyClass {}\r\n     * @observable({ name: 'firstName' }) MyClass {}\r\n     */\r\n    const isClassDecorator = key === undefined;\r\n    if (isClassDecorator) {\r\n      target = target.prototype;\r\n      key = typeof config === 'string' ? config : config.name;\r\n    }\r\n\r\n    // use a convention to compute the inner property name\r\n    const innerPropertyName = `_${key}`;\r\n    const innerPropertyDescriptor: PropertyDescriptor = {\r\n      configurable: true,\r\n      enumerable: false,\r\n      writable: true\r\n    };\r\n    if (config && 'defaultValue' in (config as IPropertyDecoratorConfig)) {\r\n      const initValue = (config as IPropertyDecoratorConfig).defaultValue;\r\n      innerPropertyDescriptor.value = coerceFunction === undefined ? initValue : coerceFunction(initValue);\r\n    }\r\n\r\n    // determine callback name based on config or convention.\r\n    const callbackName = (config && (config as IPropertyDecoratorConfig).changeHandler) || `${key}Changed`;\r\n\r\n    if (descriptor) {\r\n      // babel passes in the property descriptor with a method to get the initial value.\r\n\r\n      // set the initial value of the property if it is defined.\r\n      // also make sure it's coerced\r\n      if (typeof descriptor.initializer === 'function') {\r\n        const initValue = descriptor.initializer();\r\n        innerPropertyDescriptor.value = coerceFunction === undefined ? initValue : coerceFunction(initValue);\r\n      }\r\n    } else {\r\n      // there is no descriptor if the target was a field in TS (although Babel provides one),\r\n      // or if the decorator was applied to a class.\r\n      descriptor = {};\r\n    }\r\n    // make the accessor enumerable by default, as fields are enumerable\r\n    if (!('enumerable' in descriptor)) {\r\n      descriptor.enumerable = true;\r\n    }\r\n\r\n    // we're adding a getter and setter which means the property descriptor\r\n    // cannot have a \"value\" or \"writable\" attribute\r\n    delete descriptor.value;\r\n    delete descriptor.writable;\r\n    delete descriptor.initializer;\r\n\r\n    // Add the inner property on the prototype.\r\n    Reflect.defineProperty(target, innerPropertyName, innerPropertyDescriptor);\r\n\r\n    // add the getter and setter to the property descriptor.\r\n    descriptor.get = function(this: any) { return this[innerPropertyName]; };\r\n    descriptor.set = function(this: any, newValue: any) {\r\n      let oldValue = this[innerPropertyName];\r\n      let coercedValue = coerceFunction === undefined ? newValue : coerceFunction(newValue);\r\n      if (coercedValue === oldValue) {\r\n        return;\r\n      }\r\n\r\n      // Add the inner property on the instance and make it nonenumerable.\r\n      this[innerPropertyName] = coercedValue;\r\n      Reflect.defineProperty(this, innerPropertyName, { enumerable: false });\r\n\r\n      if (this[callbackName]) {\r\n        this[callbackName](coercedValue, oldValue, key);\r\n      }\r\n    };\r\n\r\n    // make sure Aurelia doesn't use dirty-checking by declaring the property's\r\n    // dependencies. This is the equivalent of \"@computedFrom(...)\".\r\n    (descriptor.get as Function & { dependencies?: string[] }).dependencies = [innerPropertyName];\r\n\r\n    if (isClassDecorator) {\r\n      Reflect.defineProperty(target, key, descriptor);\r\n    } else {\r\n      return descriptor;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decorating with parens\r\n   * @example\r\n   * @observable MyClass {} <----- this breaks, but will go into this condition\r\n   * @observable('firstName') MyClass {}\r\n   * @observable({ name: 'firstName' }) MyClass {}\r\n   * class MyClass {\r\n   *   @observable() prop\r\n   * }\r\n   */\r\n  if (key === undefined) {\r\n    return (t: Function, k: string, d: PropertyDescriptor) => deco(t, k, d, nameOrTargetOrConfig);\r\n  }\r\n  /**\r\n   * Decorating on class field\r\n   * @example\r\n   * class MyClass {\r\n   *   @observable prop\r\n   * }\r\n   */\r\n  return deco(nameOrTargetOrConfig as Function, key, descriptor);\r\n} as IObservableDecorator;\r\n\r\n['string', 'number', 'boolean', 'date'].forEach(createTypedObservable);\r\n\r\n/*\r\n          | typescript       | babel\r\n----------|------------------|-------------------------\r\nproperty  | config           | config\r\nw/parens  | target, key      | target, key, descriptor\r\n----------|------------------|-------------------------\r\nproperty  | target, key      | target, key, descriptor\r\nno parens | n/a              | n/a\r\n----------|------------------|-------------------------\r\nclass     | config           | config\r\n          | target           | target\r\n*/\r\n\r\n/**\r\n * Toggle the flag for observable to auto pickup property type from metadata\r\n * The reason is sometimes we may want to use prop type on bindable, but not observable\r\n * and vice versa\r\n */\r\nexport function usePropertyType(shouldUsePropType: boolean) {\r\n  _usePropertyType = !!shouldUsePropType;\r\n}\r\n\r\n/**\r\n * Decorator: Creates a new observable decorator that can be used for fluent syntax purpose\r\n * @param type the type name that will be assign to observable decorator. `createTypedObservable('point') -> observable.point`\r\n */\r\nexport function createTypedObservable(type: string): IObservableDecoratorFunction {\r\n  return (observable as any)[type] = function(\r\n    nameOrTargetOrConfig?: string | object | IPropertyDecoratorConfig,\r\n    key?: string,\r\n    descriptor?: PropertyDescriptor & { initializer?(): any }\r\n  ) {\r\n    if (nameOrTargetOrConfig === undefined) {\r\n      /**\r\n       * MyClass {\r\n       *   @observable.number() num\r\n       * }\r\n       *\r\n       * This will breaks so need to check for proper error\r\n       * @observable.number()\r\n       * class MyClass {}\r\n       */\r\n      return observable({ coerce: type });\r\n    }\r\n    if (key === undefined) {\r\n      /**\r\n       * @observable.number('num')\r\n       * class MyClass {}\r\n       *\r\n       * @observable.number({...})\r\n       * class MyClass\r\n       *\r\n       * class MyClass {\r\n       *   @observable.number({...})\r\n       *   num\r\n       * }\r\n       */\r\n      nameOrTargetOrConfig = typeof nameOrTargetOrConfig === 'string' ? { name: nameOrTargetOrConfig } : nameOrTargetOrConfig;\r\n      (nameOrTargetOrConfig as IPropertyDecoratorConfig).coerce = type;\r\n      return observable(nameOrTargetOrConfig);\r\n    }\r\n    /**\r\n     * class MyClass {\r\n     *   @observable.number num\r\n     * }\r\n     */\r\n    return (observable({ coerce: type }) as IObservableDecoratorFunction)(nameOrTargetOrConfig, key, descriptor);\r\n  };\r\n}\r\n"],"names":["_usePropertyType","usePropertyType"],"mappings":"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"}