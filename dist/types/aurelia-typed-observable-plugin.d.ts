// Generated by dts-bundle-generator v6.7.0

import { bindingMode } from 'aurelia-binding';

export declare type ICoerceFunction<T = any> = (val: any) => T;
export interface IPropertyDecoratorConfig<T = any> {
	name?: string;
	changeHandler?: string;
	defaultValue?: T;
	coerce?: string | ICoerceFunction<T>;
}
export declare type IPropertyDecoratorFunction<TValueType = any, TConfig extends IPropertyDecoratorConfig<TValueType> = IPropertyDecoratorConfig<TValueType>> = (nameOrTargetOrConfig?: string | object | TConfig, key?: string, descriptor?: PropertyDescriptor) => any;
export interface IBindablePropertyConfig<T = any> extends IPropertyDecoratorConfig<T> {
	attribute?: string;
	defaultBindingMode?: bindingMode;
	reflectToAttribute?: boolean | {
		(el: Element, name: string, newVal: any, oldVal: any): any;
	};
}
export declare type IBindableDecoratorFunction<T = any> = IPropertyDecoratorFunction<T>;
export interface IBindableDecorator<T = any> extends IBindableDecoratorFunction<T> {
	string: IBindableDecoratorFunction<string>;
	number: IBindableDecoratorFunction<number>;
	boolean: IBindableDecoratorFunction<boolean>;
	date: IBindableDecoratorFunction<Date>;
	booleanAttr: IBindableDecoratorFunction<boolean>;
	[type: string]: IBindableDecoratorFunction;
}
/**
 * Decorator: Specifies that a property is bindable through HTML.
 * @param nameOrTargetOrConfig The name of the property, or a configuration object.
 * This has Object in its type to avoid breaking change.
 * Idealy it should be `string | BindablePropertyConfig`
 */
export declare const bindable: IBindableDecorator;
declare function usePropertyType(shouldUsePropertyType: boolean): void;
/**
 * Create a new fluent syntax bindable decorator  ex: builtin: `@bindable.string`, custom: `@bindable.customType`
 * Need to use together with setting the type in `coerceFunctions`:
 *
 * ```js
 * import {
 *  createTypedBindable,
 *  coerceFunctions
 * } from 'aurelia-framework'
 *
 * // create the typed bindable
 * createTypedBindable('point'); // => enable `@bindable.point`
 * // Set the instruction
 * coerceFunctions.point = function(value: string) {
 *   // convert to point from value
 * }
 * ```
 *
 * @param type The type to added to bindable for fluent syntax.
 */
export declare function createTypedBindable(type: string): any;
export declare type IObservableDecoratorFunction<T = any> = IPropertyDecoratorFunction<T>;
export interface IObservableDecorator extends IObservableDecoratorFunction {
	string: IObservableDecoratorFunction<string>;
	number: IObservableDecoratorFunction<number>;
	boolean: IObservableDecoratorFunction<boolean>;
	date: IObservableDecoratorFunction<Date>;
	[type: string]: IObservableDecoratorFunction<any>;
}
export declare const observable: IObservableDecorator;
declare function usePropertyType(shouldUsePropType: boolean): void;
/**
 * Decorator: Creates a new observable decorator that can be used for fluent syntax purpose
 * @param type the type name that will be assign to observable decorator. `createTypedObservable('point') -> observable.point`
 */
export declare function createTypedObservable(type: string): IObservableDecoratorFunction;
export declare const coerceFunctions: Record<string, (val: any) => any>;
export declare const coerceFunctionMap: Map<Function, string>;
export interface ICoerce extends Function {
	coerce?: ICoerceFunction;
}
/**
 * Map a class to a string for typescript property coerce
 * @param type the property class to register
 * @param strType the string that represents class in the lookup
 * @param coerceFunction coerce function to register with param strType
 */
export declare function mapCoerceFunction(type: ICoerce, strType: string, coerceFunction?: ICoerceFunction): void;

export {
	usePropertyType as usePropertyTypeForBindable,
	usePropertyType as usePropertyTypeForObservable,
};

export {};
