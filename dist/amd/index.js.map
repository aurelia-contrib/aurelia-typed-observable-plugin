{"version":3,"file":"index.js","sources":["../../src/coerce-functions.ts","../../src/patches.ts","../../src/bindable.ts","../../src/observable.ts"],"sourcesContent":["import { ICoerceFunction } from './interfaces';\r\nimport * as LogManager from 'aurelia-logging';\r\n\r\nexport const coerceFunctions: Record<string, (val: any) => any> = {\r\n  none(a: any) {\r\n    return a;\r\n  },\r\n  number(a: any) {\r\n    return Number(a);\r\n  },\r\n  string(a: any) {\r\n    return '' + a;\r\n  },\r\n  boolean(a: any) {\r\n    return !!a;\r\n  },\r\n  booleanAttr(val: any) {\r\n    return val || val === '' ? true : false;\r\n  },\r\n  date(val: any) {\r\n    // Invalid date instances are quite problematic\r\n    // so we need to deal with it properly by default\r\n    if (val === null || val === undefined) {\r\n      return null;\r\n    }\r\n    const d = new Date(val);\r\n    return isNaN(d.getTime()) ? null : d;\r\n  }\r\n};\r\n\r\n\r\nexport const coerceFunctionMap: Map<Function, string> = new Map([\r\n  [Boolean, 'boolean'],\r\n  [String, 'string'],\r\n  [Date, 'date'],\r\n  [Number, 'number'],\r\n] as any);\r\n\r\nexport interface ICoerce extends Function {\r\n  coerce?: ICoerceFunction;\r\n}\r\n\r\n/**\r\n * Map a class to a string for typescript property coerce\r\n * @param type the property class to register\r\n * @param strType the string that represents class in the lookup\r\n * @param coerceFunction coerce function to register with param strType\r\n */\r\nexport function mapCoerceFunction(type: ICoerce, strType: string, coerceFunction?: ICoerceFunction) {\r\n  coerceFunction = coerceFunction || type.coerce;\r\n  if (typeof strType !== 'string' || typeof coerceFunction !== 'function') {\r\n    LogManager\r\n      .getLogger('map-coerce-function')\r\n      .warn(`Bad attempt at mapping coerce function for type: ${type.name} to: ${strType}`);\r\n    return;\r\n  }\r\n  coerceFunctions[strType] = coerceFunction;\r\n  coerceFunctionMap.set(type, strType);\r\n}\r\n","// tslint:disable: interface-name no-invalid-this no-non-null-assertion\r\nimport * as LogManager from 'aurelia-logging';\r\nimport { TaskQueue } from 'aurelia-task-queue';\r\nimport { BehaviorPropertyObserver, BindableProperty, HtmlBehaviorResource } from 'aurelia-templating';\r\nimport { coerceFunctions } from './coerce-functions';\r\nimport { ICoerceFunction } from './interfaces';\r\n\r\n/** @internal */\r\ndeclare module 'aurelia-templating' {\r\n  interface BehaviorPropertyObserver {\r\n    coerce?: ICoerceFunction;\r\n    // currentValue: any;\r\n    // oldValue: any;\r\n    // selfSubscriber: Function | null;\r\n    setCoerce(coerce: string | Function | undefined): void;\r\n  }\r\n\r\n  interface BindableProperty {\r\n    name: any;\r\n    coerce: string | ICoerceFunction | undefined;\r\n  }\r\n}\r\n\r\ninterface ExtendedBehaviorPropertyObserver extends BehaviorPropertyObserver {\r\n  // coerce?: ICoerceFunction;\r\n  currentValue: any;\r\n  oldValue: any;\r\n  selfSubscriber: Function | null;\r\n  notqueued: boolean;\r\n  publishing: boolean;\r\n  taskQueue: TaskQueue;\r\n  // setCoerce(coerce: string | Function | undefined): void;\r\n}\r\n\r\ninterface BindablePropertyForeignExtension {\r\n  changeHandler: string;\r\n  defaultValue: any;\r\n  owner: HtmlBehaviorResource & { taskQueue: TaskQueue };\r\n}\r\n\r\ninterface ExtendedBindableProperty extends BindableProperty {\r\n  changeHandler: string;\r\n  defaultValue: any;\r\n  owner: HtmlBehaviorResource & { taskQueue: TaskQueue };\r\n}\r\n\r\nBehaviorPropertyObserver.prototype.setCoerce = function(coerce: string | ICoerceFunction): void {\r\n  this.coerce = typeof coerce === 'function' ? coerce : coerceFunctions[coerce];\r\n  if (this.coerce === undefined) {\r\n    LogManager\r\n      .getLogger('behavior-property-observer')\r\n      .warn(`Invalid coerce instruction. Should be either one of ${Object.keys(coerceFunctions)} or a function.`);\r\n  }\r\n};\r\n\r\n/**\r\n * Slightly override the builtin implementation that will handle coercion\r\n */\r\nBehaviorPropertyObserver.prototype.setValue = function(\r\n  this: BehaviorPropertyObserver & ExtendedBehaviorPropertyObserver,\r\n  newValue: any\r\n): void {\r\n  const oldValue = this.currentValue;\r\n  const coercedValue = this.coerce === undefined ? newValue : this.coerce(newValue);\r\n\r\n  if (oldValue !== coercedValue) {\r\n    this.oldValue = oldValue;\r\n    this.currentValue = coercedValue;\r\n\r\n    if (this.publishing && this.notqueued) {\r\n      if (this.taskQueue.flushing) {\r\n        this.call();\r\n      } else {\r\n        this.notqueued = false;\r\n        this.taskQueue.queueMicroTask(this);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nBindableProperty.prototype.createObserver = function(\r\n  this: ExtendedBindableProperty,\r\n  viewModel: any\r\n): BehaviorPropertyObserver {\r\n  let selfSubscriber: Function | null = null;\r\n  const defaultValue = this.defaultValue;\r\n  const changeHandlerName = this.changeHandler;\r\n  const name = this.name;\r\n  let initialValue;\r\n\r\n  if ((this as any).hasOptions) {\r\n    return undefined;\r\n  }\r\n\r\n  if (changeHandlerName in viewModel) {\r\n    if ('propertyChanged' in viewModel) {\r\n      selfSubscriber = (newValue: any, oldValue: any) => {\r\n        viewModel[changeHandlerName](newValue, oldValue);\r\n        viewModel.propertyChanged(name, newValue, oldValue);\r\n      };\r\n    } else {\r\n      selfSubscriber = (newValue: any, oldValue: any) => viewModel[changeHandlerName](newValue, oldValue);\r\n    }\r\n  } else if ('propertyChanged' in viewModel) {\r\n    selfSubscriber = (newValue: any, oldValue: any) => viewModel.propertyChanged(name, newValue, oldValue);\r\n  } else if (changeHandlerName !== null) {\r\n    throw new Error(`Change handler ${changeHandlerName} was specified but not declared on the class.`);\r\n  }\r\n\r\n  if (defaultValue !== undefined) {\r\n    initialValue = typeof defaultValue === 'function' ? defaultValue.call(viewModel) : defaultValue;\r\n  }\r\n\r\n  const observer: ExtendedBehaviorPropertyObserver = new BehaviorPropertyObserver(\r\n    this.owner.taskQueue,\r\n    viewModel,\r\n    this.name,\r\n    selfSubscriber,\r\n    initialValue\r\n  ) as any;\r\n  if (this.coerce !== undefined) {\r\n    observer.setCoerce(this.coerce);\r\n    observer.currentValue = observer.oldValue = observer.coerce === undefined ? observer.currentValue : observer.coerce(initialValue);\r\n  }\r\n\r\n  return observer;\r\n};\r\n\r\n(BindableProperty as any).prototype._createDynamicProperty = function(\r\n  this: BindableProperty & BindablePropertyForeignExtension,\r\n  viewModel: any,\r\n  observerLookup: Record<string, ExtendedBehaviorPropertyObserver>,\r\n  behaviorHandlesBind: boolean,\r\n  name: string,\r\n  attribute: string | { createBinding(viewModel: any): any },\r\n  boundProperties: any[]\r\n): void {\r\n  const changeHandlerName = `${name}Changed`;\r\n  let selfSubscriber: Function | null = null;\r\n  let observer: ExtendedBehaviorPropertyObserver;\r\n  let info;\r\n\r\n  if (changeHandlerName in viewModel) {\r\n    if ('propertyChanged' in viewModel) {\r\n      selfSubscriber = (newValue: any, oldValue: any) => {\r\n        viewModel[changeHandlerName](newValue, oldValue);\r\n        viewModel.propertyChanged(name, newValue, oldValue);\r\n      };\r\n    } else {\r\n      selfSubscriber = (newValue: any, oldValue: any) => viewModel[changeHandlerName](newValue, oldValue);\r\n    }\r\n  } else if ('propertyChanged' in viewModel) {\r\n    selfSubscriber = (newValue: any, oldValue: any) => viewModel.propertyChanged(name, newValue, oldValue);\r\n  }\r\n\r\n  observer = observerLookup[name] = new BehaviorPropertyObserver(\r\n    this.owner.taskQueue,\r\n    viewModel,\r\n    name,\r\n    selfSubscriber,\r\n    undefined\r\n  ) as ExtendedBehaviorPropertyObserver;\r\n\r\n  observer.setCoerce(this.coerce);\r\n  observer.currentValue = observer.oldValue = observer.coerce === undefined ? observer.currentValue : observer.coerce(undefined);\r\n\r\n  Object.defineProperty(viewModel, name, {\r\n    configurable: true,\r\n    enumerable: true,\r\n    get: observer.getValue.bind(observer),\r\n    set: observer.setValue.bind(observer)\r\n  });\r\n\r\n  if (behaviorHandlesBind) {\r\n    observer.selfSubscriber = null;\r\n  }\r\n\r\n  if (typeof attribute === 'string') {\r\n    viewModel[name] = attribute;\r\n    observer.call();\r\n  } else if (attribute) {\r\n    info = { observer: observer, binding: attribute.createBinding(viewModel) };\r\n    boundProperties.push(info);\r\n  }\r\n\r\n  observer.publishing = true;\r\n  observer.selfSubscriber = selfSubscriber;\r\n};\r\n","// tslint:disable: no-reserved-keywords no-function-expressions no-parameter-reassignment no-import-side-effect callable-types\r\nimport { bindingMode } from 'aurelia-binding';\r\nimport * as LogManager from 'aurelia-logging';\r\nimport { metadata } from 'aurelia-metadata';\r\nimport { BindableProperty, HtmlBehaviorResource } from 'aurelia-templating';\r\nimport { coerceFunctionMap, coerceFunctions } from './coerce-functions';\r\nimport { IPropertyDecoratorConfig, IPropertyDecoratorFunction } from './interfaces';\r\nimport './patches';\r\n\r\nlet _usePropertyType = false;\r\n\r\nexport interface IBindablePropertyConfig<T = any> extends IPropertyDecoratorConfig<T> {\r\n  attribute?: string;\r\n  defaultBindingMode?: bindingMode;\r\n  reflectToAttribute?: boolean | { (el: Element, name: string, newVal: any, oldVal: any): any };\r\n}\r\n\r\nexport type IBindableDecoratorFunction<T = any> = IPropertyDecoratorFunction<T>\r\n\r\nexport interface IBindableDecorator<T = any> extends IBindableDecoratorFunction<T> {\r\n  string: IBindableDecoratorFunction<string>;\r\n  number: IBindableDecoratorFunction<number>;\r\n  boolean: IBindableDecoratorFunction<boolean>;\r\n  date: IBindableDecoratorFunction<Date>;\r\n  booleanAttr: IBindableDecoratorFunction<boolean>;\r\n  [type: string]: IBindableDecoratorFunction;\r\n}\r\n\r\n/**\r\n * Decorator: Specifies that a property is bindable through HTML.\r\n * @param nameOrTargetOrConfig The name of the property, or a configuration object.\r\n * This has Object in its type to avoid breaking change.\r\n * Idealy it should be `string | BindablePropertyConfig`\r\n */\r\n// tslint:disable-next-line:no-shadowed-variable\r\nexport const bindable: IBindableDecorator = function bindable(\r\n  nameOrTargetOrConfig?: string | object | IBindablePropertyConfig,\r\n  key?: string,\r\n  descriptor?: PropertyDescriptor\r\n): any {\r\n  const deco = function(target: Function, key2?: string, descriptor2?: PropertyDescriptor): any {\r\n    /**\r\n     * key2 = truthy => decorated on a class field\r\n     * key2 = falsy => decorated on a class\r\n     */\r\n    const actualTarget = key2 ? target.constructor : target;\r\n    const r = metadata.getOrCreateOwn(metadata.resource, HtmlBehaviorResource, actualTarget) as HtmlBehaviorResource;\r\n    let prop: BindableProperty;\r\n    let propType: Function;\r\n\r\n    if (key2) { //is it on a property or a class?\r\n      nameOrTargetOrConfig = nameOrTargetOrConfig || {};\r\n      (nameOrTargetOrConfig as IBindablePropertyConfig).name = key2;\r\n      /**\r\n       * Support for Typescript decorator, with metadata on property type.\r\n       * Will check for typing only when user didn't explicitly set coerce + turn on the options\r\n       *\r\n       * If key 2 is truthy, it's a decorator on class field, which means target is prototype\r\n       */\r\n      if ((nameOrTargetOrConfig as IBindablePropertyConfig).coerce === undefined && _usePropertyType) {\r\n        propType = metadata.getOwn(metadata.propertyType, target, key2) as any;\r\n        if (propType) {\r\n          const coerceType = coerceFunctionMap.get(propType);\r\n          if (coerceType === undefined) {\r\n            LogManager\r\n              .getLogger('@bindable decorator')\r\n              .warn(`Invalid coerce instruction. Should be either one of ${Object.keys(coerceFunctions)} or a function.`);\r\n          }\r\n          (nameOrTargetOrConfig as IBindablePropertyConfig).coerce = coerceType || 'none';\r\n        }\r\n      }\r\n    }\r\n\r\n    prop = new BindableProperty((nameOrTargetOrConfig as IBindablePropertyConfig));\r\n\r\n    return prop.registerWith(actualTarget, r, descriptor2);\r\n  };\r\n\r\n  if (!nameOrTargetOrConfig) {\r\n    /**\r\n     * placed on property initializer with parens, without any params\r\n     * @example:\r\n     * class ViewModel {\r\n     *   @bindable() property\r\n     * }\r\n     * @bindable() class ViewModel {}\r\n     */\r\n    return deco;\r\n  }\r\n\r\n  if (key) {\r\n    /**\r\n     * placed on a property initializer without parens\r\n     * @example\r\n     * class ViewModel {\r\n     *   @bindable property\r\n     * }\r\n     *\r\n     */\r\n    const target = nameOrTargetOrConfig;\r\n    nameOrTargetOrConfig = undefined;\r\n\r\n    return deco(target as Function, key, descriptor);\r\n  }\r\n\r\n  /**\r\n   * placed on a class with parens and config\r\n   * @example\r\n   * @bindable({ ... })\r\n   * class MyViewModel {}\r\n   */\r\n  return deco;\r\n} as IBindableDecorator;\r\n\r\n['string', 'number', 'boolean', 'booleanAttr', 'date'].forEach(createTypedBindable);\r\n\r\n/**\r\n * Used to allow user to automatically pickup property type\r\n * Can be used with typescript emit metadata in compiler settings, or with `Reflect.metadata('design:type', PropertyTypeClass)` decorator\r\n */\r\nexport function usePropertyType(shouldUsePropertyType: boolean): void {\r\n  _usePropertyType = shouldUsePropertyType;\r\n}\r\n\r\n/**\r\n * Create a new fluent syntax bindable decorator  ex: builtin: `@bindable.string`, custom: `@bindable.customType`\r\n * Need to use together with setting the type in `coerceFunctions`:\r\n *\r\n * ```js\r\n * import {\r\n *  createTypedBindable,\r\n *  coerceFunctions\r\n * } from 'aurelia-framework'\r\n *\r\n * // create the typed bindable\r\n * createTypedBindable('point'); // => enable `@bindable.point`\r\n * // Set the instruction\r\n * coerceFunctions.point = function(value: string) {\r\n *   // convert to point from value\r\n * }\r\n * ```\r\n *\r\n * @param type The type to added to bindable for fluent syntax.\r\n */\r\nexport function createTypedBindable(type: string): any {\r\n  /**\r\n   * There no attempts to protect user from mis-using the decorators.\r\n   * ex. @observable({}, accidentParam) class SomeClass {}\r\n   * If we have some flag to use in if block, which can be remove at build time, it would be great.\r\n   */\r\n  return (bindable as any)[type] = function(\r\n    nameOrTargetOrConfig?: string | object | IBindablePropertyConfig,\r\n    key?: string,\r\n    descriptor?: PropertyDescriptor\r\n  ): any {\r\n    if (nameOrTargetOrConfig === undefined) {\r\n      /**\r\n       * MyClass {\r\n       *   @bindable.number() num\r\n       * }\r\n       */\r\n      return bindable({ coerce: type });\r\n    }\r\n    if (key === undefined) {\r\n      /**\r\n       * @bindable.number('num')\r\n       * class MyClass {}\r\n       *\r\n       * @bindable.number({...})\r\n       * class MyClass\r\n       *\r\n       * class MyClass {\r\n       *   @bindable.number({...})\r\n       *   num\r\n       * }\r\n       */\r\n      nameOrTargetOrConfig = typeof nameOrTargetOrConfig === 'string' ? { name: nameOrTargetOrConfig } : nameOrTargetOrConfig;\r\n      (nameOrTargetOrConfig as IBindablePropertyConfig).coerce = type;\r\n\r\n      return bindable(nameOrTargetOrConfig);\r\n    }\r\n\r\n    /**\r\n     * class MyClass {\r\n     *   @bindable.number num\r\n     * }\r\n     */\r\n    return bindable({ coerce: type })(nameOrTargetOrConfig, key, descriptor);\r\n  };\r\n}\r\n","import { ICoerceFunction, IPropertyDecoratorConfig, IPropertyDecoratorFunction } from './interfaces';\r\nimport { coerceFunctions, coerceFunctionMap } from './coerce-functions';\r\nimport { metadata } from 'aurelia-metadata';\r\nimport * as LogManager from 'aurelia-logging';\r\n\r\nconst observableLogger = LogManager.getLogger('aurelia-observable-decorator');\r\n\r\n/**\r\n * Internal flag to turn on / off auto pickup property type from metadata\r\n */\r\nlet _usePropertyType = false;\r\n\r\n// export interface ObservablePropertyConfig<T = any> {\r\n//   name?: string;\r\n//   changeHandler?: string;\r\n//   defaultValue?: T;\r\n//   coerce?: string | ICoerceFunction<T>;\r\n// }\r\n\r\n// export type IObservableDecoratorFunction<T = any> = (nameOrTargetOrConfig: string | Function | ObservablePropertyConfig<T>, key?: string, descriptor?: PropertyDescriptor) => any;\r\n\r\nexport type IObservableDecoratorFunction<T = any> = IPropertyDecoratorFunction<T>\r\n\r\nexport interface IObservableDecorator extends IObservableDecoratorFunction {\r\n  // usePropertyType(shouldUsePropType: boolean): void;\r\n  string: IObservableDecoratorFunction<string>;\r\n  number: IObservableDecoratorFunction<number>;\r\n  boolean: IObservableDecoratorFunction<boolean>;\r\n  date: IObservableDecoratorFunction<Date>;\r\n  [type: string]: IObservableDecoratorFunction<any>;\r\n}\r\n\r\nexport const observable: IObservableDecorator = function observable(nameOrTargetOrConfig?: string | object | IPropertyDecoratorConfig, key?: string, descriptor?: PropertyDescriptor) {\r\n  /**\r\n   * @param target The class decorated\r\n   * @param key The target class field of the decorator\r\n   * @param descriptor class field descriptor\r\n   * @param config user's config\r\n   */\r\n  function deco(target: Function, key?: string, descriptor?: PropertyDescriptor & { initializer?(): any }, config?: string | IPropertyDecoratorConfig): any {\r\n    // Used to check if we should pickup the type from metadata\r\n    let coerce: string | ICoerceFunction | undefined = config === undefined || typeof config === 'string' ? undefined : config.coerce;\r\n    let propType: Function | undefined;\r\n    let coerceFunction: ICoerceFunction | undefined;\r\n\r\n    if (coerce) {\r\n      switch (typeof coerce) {\r\n        case 'string':\r\n          coerceFunction = coerceFunctions[coerce as string]; break;\r\n        case 'function':\r\n          coerceFunction = coerce as ICoerceFunction; break;\r\n        default: break;\r\n      }\r\n      if (coerceFunction === undefined) {\r\n        observableLogger.warn(`Invalid coerce instruction. Should be either one of ${Object.keys(coerceFunctions)} or a function.`);\r\n      }\r\n    } else if (_usePropertyType) {\r\n      propType = metadata.getOwn(metadata.propertyType, target, key) as any;\r\n      if (propType) {\r\n        coerceFunction = coerceFunctions[coerceFunctionMap.get(propType)];\r\n        if (coerceFunction === undefined) {\r\n          observableLogger.warn(`Unable to find coerce function for type ${propType.name}.`);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * class decorator?\r\n     * @example\r\n     * @observable('firstName') MyClass {}\r\n     * @observable({ name: 'firstName' }) MyClass {}\r\n     */\r\n    const isClassDecorator = key === undefined;\r\n    if (isClassDecorator) {\r\n      target = target.prototype;\r\n      key = typeof config === 'string' ? config : config.name;\r\n    }\r\n\r\n    // use a convention to compute the inner property name\r\n    const innerPropertyName = `_${key}`;\r\n    const innerPropertyDescriptor: PropertyDescriptor = {\r\n      configurable: true,\r\n      enumerable: false,\r\n      writable: true\r\n    };\r\n    if (config && 'defaultValue' in (config as IPropertyDecoratorConfig)) {\r\n      const initValue = (config as IPropertyDecoratorConfig).defaultValue;\r\n      innerPropertyDescriptor.value = coerceFunction === undefined ? initValue : coerceFunction(initValue);\r\n    }\r\n\r\n    // determine callback name based on config or convention.\r\n    const callbackName = (config && (config as IPropertyDecoratorConfig).changeHandler) || `${key}Changed`;\r\n\r\n    if (descriptor) {\r\n      // babel passes in the property descriptor with a method to get the initial value.\r\n\r\n      // set the initial value of the property if it is defined.\r\n      // also make sure it's coerced\r\n      if (typeof descriptor.initializer === 'function') {\r\n        const initValue = descriptor.initializer();\r\n        innerPropertyDescriptor.value = coerceFunction === undefined ? initValue : coerceFunction(initValue);\r\n      }\r\n    } else {\r\n      // there is no descriptor if the target was a field in TS (although Babel provides one),\r\n      // or if the decorator was applied to a class.\r\n      descriptor = {};\r\n    }\r\n    // make the accessor enumerable by default, as fields are enumerable\r\n    if (!('enumerable' in descriptor)) {\r\n      descriptor.enumerable = true;\r\n    }\r\n\r\n    // we're adding a getter and setter which means the property descriptor\r\n    // cannot have a \"value\" or \"writable\" attribute\r\n    delete descriptor.value;\r\n    delete descriptor.writable;\r\n    delete descriptor.initializer;\r\n\r\n    // Add the inner property on the prototype.\r\n    Reflect.defineProperty(target, innerPropertyName, innerPropertyDescriptor);\r\n\r\n    // add the getter and setter to the property descriptor.\r\n    descriptor.get = function(this: any) { return this[innerPropertyName]; };\r\n    descriptor.set = function(this: any, newValue: any) {\r\n      let oldValue = this[innerPropertyName];\r\n      let coercedValue = coerceFunction === undefined ? newValue : coerceFunction(newValue);\r\n      if (coercedValue === oldValue) {\r\n        return;\r\n      }\r\n\r\n      // Add the inner property on the instance and make it nonenumerable.\r\n      this[innerPropertyName] = coercedValue;\r\n      Reflect.defineProperty(this, innerPropertyName, { enumerable: false });\r\n\r\n      if (this[callbackName]) {\r\n        this[callbackName](coercedValue, oldValue, key);\r\n      }\r\n    };\r\n\r\n    // make sure Aurelia doesn't use dirty-checking by declaring the property's\r\n    // dependencies. This is the equivalent of \"@computedFrom(...)\".\r\n    (descriptor.get as Function & { dependencies?: string[] }).dependencies = [innerPropertyName];\r\n\r\n    if (isClassDecorator) {\r\n      Reflect.defineProperty(target, key, descriptor);\r\n    } else {\r\n      return descriptor;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decorating with parens\r\n   * @example\r\n   * @observable MyClass {} <----- this breaks, but will go into this condition\r\n   * @observable('firstName') MyClass {}\r\n   * @observable({ name: 'firstName' }) MyClass {}\r\n   * class MyClass {\r\n   *   @observable() prop\r\n   * }\r\n   */\r\n  if (key === undefined) {\r\n    return (t: Function, k: string, d: PropertyDescriptor) => deco(t, k, d, nameOrTargetOrConfig);\r\n  }\r\n  /**\r\n   * Decorating on class field\r\n   * @example\r\n   * class MyClass {\r\n   *   @observable prop\r\n   * }\r\n   */\r\n  return deco(nameOrTargetOrConfig as Function, key, descriptor);\r\n} as IObservableDecorator;\r\n\r\n['string', 'number', 'boolean', 'date'].forEach(createTypedObservable);\r\n\r\n/*\r\n          | typescript       | babel\r\n----------|------------------|-------------------------\r\nproperty  | config           | config\r\nw/parens  | target, key      | target, key, descriptor\r\n----------|------------------|-------------------------\r\nproperty  | target, key      | target, key, descriptor\r\nno parens | n/a              | n/a\r\n----------|------------------|-------------------------\r\nclass     | config           | config\r\n          | target           | target\r\n*/\r\n\r\n/**\r\n * Toggle the flag for observable to auto pickup property type from metadata\r\n * The reason is sometimes we may want to use prop type on bindable, but not observable\r\n * and vice versa\r\n */\r\nexport function usePropertyType(shouldUsePropType: boolean) {\r\n  _usePropertyType = !!shouldUsePropType;\r\n}\r\n\r\n/**\r\n * Decorator: Creates a new observable decorator that can be used for fluent syntax purpose\r\n * @param type the type name that will be assign to observable decorator. `createTypedObservable('point') -> observable.point`\r\n */\r\nexport function createTypedObservable(type: string): IObservableDecoratorFunction {\r\n  return (observable as any)[type] = function(\r\n    nameOrTargetOrConfig?: string | object | IPropertyDecoratorConfig,\r\n    key?: string,\r\n    descriptor?: PropertyDescriptor & { initializer?(): any }\r\n  ) {\r\n    if (nameOrTargetOrConfig === undefined) {\r\n      /**\r\n       * MyClass {\r\n       *   @observable.number() num\r\n       * }\r\n       *\r\n       * This will breaks so need to check for proper error\r\n       * @observable.number()\r\n       * class MyClass {}\r\n       */\r\n      return observable({ coerce: type });\r\n    }\r\n    if (key === undefined) {\r\n      /**\r\n       * @observable.number('num')\r\n       * class MyClass {}\r\n       *\r\n       * @observable.number({...})\r\n       * class MyClass\r\n       *\r\n       * class MyClass {\r\n       *   @observable.number({...})\r\n       *   num\r\n       * }\r\n       */\r\n      nameOrTargetOrConfig = typeof nameOrTargetOrConfig === 'string' ? { name: nameOrTargetOrConfig } : nameOrTargetOrConfig;\r\n      (nameOrTargetOrConfig as IPropertyDecoratorConfig).coerce = type;\r\n      return observable(nameOrTargetOrConfig);\r\n    }\r\n    /**\r\n     * class MyClass {\r\n     *   @observable.number num\r\n     * }\r\n     */\r\n    return (observable({ coerce: type }) as IObservableDecoratorFunction)(nameOrTargetOrConfig, key, descriptor);\r\n  };\r\n}\r\n"],"names":["LogManager","BehaviorPropertyObserver","BindableProperty","_usePropertyType","metadata","HtmlBehaviorResource","usePropertyType"],"mappings":"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"}